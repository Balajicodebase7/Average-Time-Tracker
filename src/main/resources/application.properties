server.port=9000

# MySQL Database Configuration
#
# When running your application or tests directly on your host machine (e.g., via IntelliJ, 'mvn spring-boot:run', or 'mvn test'):
# These values will be used to connect to your MySQL Docker container mapped to localhost:3306.
# Ensure your MySQL container is running via 'docker compose up -d mysql_db' before running locally.
spring.datasource.url=jdbc:mysql://localhost:3310/tasktrackerdb?useSSL=false&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true
spring.datasource.username=taskuser
spring.datasource.password=securepassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# When running your application in a Docker Compose environment:
# Spring Boot will prioritize environment variables (e.g., SPRING_DATASOURCE_URL)
# over these properties, which is the expected behavior for containerized deployments.
# For example, your docker-compose.yml would define:
#   environment:
#     - SPRING_DATASOURCE_URL=jdbc:mysql://mysql_db:3306/tasktrackerdb?...
#     - SPRING_DATASOURCE_USERNAME=taskuser
#     - SPRING_DATASOURCE_PASSWORD=securepassword

# JPA/Hibernate Configuration
# 'update' is suitable for development and testing as it creates/updates schema based on entities.
# For production environments, consider 'validate' or 'none' in conjunction with a dedicated
# database migration tool like Flyway or Liquibase for robust schema management.
spring.jpa.hibernate.ddl-auto=update
# Enable showing SQL queries in logs, very useful for debugging database interactions.
spring.jpa.show-sql=true
# Format the displayed SQL queries for better readability.
spring.jpa.properties.hibernate.format_sql=true

# No H2 Console as H2 is not being used.
spring.h2.console.enabled=false